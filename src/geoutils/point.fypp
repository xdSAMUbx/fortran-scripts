#:set dtypes = [("i","integer","int64"),("r","real","real128")]
#:set puntos = ["Point2d","Point3d","Point4d"]
#:set args = ["x","y","z","t"]
#:set values = ["s","arr"]

module mod_point
   use iso_fortran_env
   implicit none

!------------------------------------------
!------------- Definición de tipos --------
!------------------------------------------
#:for prefix, ftype, isotype in dtypes
#:for i, pts in enumerate(puntos)
#:if pts == "Point2d"
   type :: ${prefix}$${pts}$
   ${ftype}$(${isotype}$) :: ${", ".join(args[0:2])}$
   end type ${prefix}$${pts}$

#:else
   type, extends(${prefix}$${puntos[i-1]}$) :: ${prefix}$${pts}$
   ${ftype}$(${isotype}$) :: ${args[i+1]}$
   end type ${prefix}$${pts}$

#:endif
#:endfor
#:endfor

!------------------------------------------
!------------- Interfaz pública -----------
!------------------------------------------
   interface point
#:for prefix, ftype, isotype in dtypes
#:for pts in puntos
#:for val in values
      module procedure ${prefix}$${pts}$${val}$
#:endfor
#:endfor
#:endfor
   end interface point

   contains

!------------------------------------------
!------------- Constructores --------------
!------------------------------------------
#:for prefix, ftype, isotype in dtypes
! ${ftype}$ part
#:for id, pts in enumerate(puntos)
#:for val in values
   pure function ${prefix}$${pts}$${val}$(${", ".join(args[0:2+id])}$) result(res)
   implicit none
#:if val == "s"
   ${ftype}$(${isotype}$), intent(in) :: ${", ".join(args[0:2+id])}$
   type(${prefix}$${pts}$) :: res

   res = ${prefix}$${pts}$(${", ".join(args[0:2+id])}$)
#:else
   ${ftype}$(${isotype}$), intent(in) :: ${"(:), ".join(args[0:2+id])}$(:)
   type(${prefix}$${pts}$), allocatable :: res(:)
   integer :: i

   allocate(res(size(${args[0]}$)))
   do concurrent (i=1:size(${args[0]}$))
      res(i) = ${prefix}$${pts}$(${", ".join([arg + '(i)' for arg in args[0:2+id]])}$)
   end do
#:endif
   end function ${prefix}$${pts}$${val}$

#:endfor
#:endfor
#:endfor

end module mod_point
