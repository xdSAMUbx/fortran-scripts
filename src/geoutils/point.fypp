#:set dtypes = [("i","integer","int64"),("r","real","real128")]
#:set puntos = ["Point2d","Point3d","Point4d"]
#:set args = ["x","y","z","t"]
#:set values = ["s","arr"]

module mod_point
   use iso_fortran_env
   implicit none
#:for prefix, ftype, isotype in dtypes
#:for i, pts in enumerate(puntos)
#:if pts == "Point2d"
   type :: ${prefix}$${pts}$
   ${ftype}$(${isotype}$) :: ${", ".join(args[0:2])}$
   end type ${prefix}$${pts}$

#:else
   type, extends(${prefix}$${puntos[i-1]}$) :: ${prefix}$${pts}$
#:for j in range(1)
   ${ftype}$(${isotype}$) :: ${args[j+i+1]}$
#:endfor
   end type ${prefix}$${pts}$

#:endif
#:endfor
#:endfor
   contains

#:for prefix, ftype, isotype in dtypes
#:for id, pts in enumerate(puntos)
#:for val in values
#:if id == 0
   pure function ${prefix}$${pts}$${val}$(${", ".join(args[0:2])}$) result(res)
   implicit none

#:if val == "s"
   ${ftype}$(${isotype}$), intent(in) :: ${", ".join(args[0:2])}$
   type(${prefix}$${pts}$) :: res

#:for j in range(2)
   res%${args[j]}$ = ${args[j]}$
#:endfor
#:else
   ${ftype}$(${isotype}$), intent(in) :: ${"(:), ".join(args[0:2])}$(:)
   ${ftype}$(${isotype}$), allocatable :: res
#:endif
   end function ${prefix}$${pts}$${val}$

#:else
#! Aqu√≠ inicia el bucle para los valores de 3 y 4 puntos
   pure function ${prefix}$${pts}$${val}$(${", ".join(args[0:2+id])}$) result(res)
   implicit none

#:if val == "s"
   ${ftype}$(${isotype}$), intent(in) :: ${", ".join(args[0:2+id])}$
   type(${prefix}$${pts}$)  :: res

#:for j in range(0,2+id)
   res%${args[j]}$ = ${args[j]}$
#:endfor
#:else
   ${ftype}$(${isotype}$), intent(in) :: ${"(:), ".join(args[0:2+id])}$(:)
   ${ftype}$(${isotype}$), allocatable :: res
#:endif
   end function ${prefix}$${pts}$${val}$

#:endif
#:endfor
#:endfor
#:endfor
end module mod_point
